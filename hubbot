#! /usr/bin/python

import subprocess
import json
import os
import sys
import errno
import shutil
import traceback
import glob
import ast
import pprint
import time

dry_run = False
verbose = False

keep_work_dirs = 30
work = "%s/hubbot/" % os.environ['HOME']
work_url = "http://files.cockpit-project.org/hubbot"

config = ast.literal_eval(open("%s/.hubbotrc" % os.environ['HOME']).read())

github_token = config['github_token']
user_whitelist = config['user_whitelist']

def mk_exclusive_dir(path):
    try:
        os.mkdir(path)
        return True
    except OSError as e:
        if e.errno == errno.EEXIST:
            return False
        else:
            raise e

class WorkDir(object):
    def __init__(self, name):
        i = 0
        n = name
        while not mk_exclusive_dir (os.path.join (work, n)):
            i = i + 1
            n = name + "." + str(i)
        self.path = os.path.join (work, n)
        if work_url:
            self.url = os.path.join (work_url, n)

    def __enter__(self):
        if verbose:
            print "Entering %s" % self.path
        self.oldcwd = os.getcwd()
        os.chdir(self.path)
        self.log = open("hubbot.log", 'w', 1)
        if verbose:
            self.tail = subprocess.Popen([ "tail", "-f", "hubbot.log" ])
        else:
            self.tail = None
        self.old_stdout, self.old_stderr = sys.stdout, sys.stderr
        self.old_stdout.flush(); self.old_stderr.flush()
        sys.stdout = self.log
        sys.stderr = self.log
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.log.flush()
        if self.tail:
            self.tail.kill()
            self.tail.wait()
        sys.stdout = self.old_stdout
        sys.stderr = self.old_stderr
        if verbose:
            print "Leaving %s" % self.path

def expire_work_dirs():
    dirs = sorted (map (lambda e: (os.stat(e).st_mtime,e),
                        map (lambda e: os.path.join(work,e),
                             filter (lambda e: e != "data",
                                     os.listdir(work)))),
                   lambda x,y: cmp(x[0],y[0]))
    if len(dirs) > keep_work_dirs:
        for d in dirs[0:len(dirs)-keep_work_dirs]:
            if verbose:
                print "Expiring %s" % d[1]
            shutil.rmtree(d[1])

def cmd(*args):
    print "+", " ".join(list(args))
    subprocess.check_call(list(args), stdout=sys.stdout, stderr=sys.stderr)

def cmd_output(*args):
    return subprocess.check_output(list(args))

def git(*args):
    cmd("git", *args)

def git_output(*args):
    return cmd_output("git", *args)

def github_get(url):
    return json.loads(subprocess.check_output ([ "curl", "-s",
                                                 "-u", "%s:x-oauth-basic" % github_token,
                                                 "https://api.github.com/repos/%s/%s" % (master_repo, url),
]))

def add_github_comment(issue, message):
    subprocess.check_call ([ "curl", "-s",
                             "-u", "%s:x-oauth-basic" % github_token,
                             "https://api.github.com/repos/%s/issues/%s/comments" % (master_repo, issue),
                             "-d", json.dumps({"body": message})
                           ])

def set_github_status(repo, sha, status):
    if dry_run:
        print "Status %s: %s %s" % (sha, status['state'], status['description'])
    else:
        subprocess.check_output ([ "curl", "-s",
                                   "-u", "%s:x-oauth-basic" % github_token,
                                   "https://api.github.com/repos/%s/statuses/%s" % (repo, sha),
                                   "-d", json.dumps(status)
                                 ])

def add_comment(issue, message):
    if issue:
        add_github_comment(issue, message)
    else:
        print "+++ %s" % message

def verify(head):
    pull_repo = head['repo']['full_name']
    ref = head['ref']
    sha = head['sha']
    context = "hubbot/f21/x86-64"
    rebase_done = False
    with WorkDir(sha) as wd:
        try:
            set_github_status(master_repo, sha, { "state": "pending",
                                                  "description": "Hubbot is busy",
                                                  "target_url": wd.url,
                                                  "context": context })
            if not dry_run:
                git("init")
                git("fetch", "https://github.com/%s.git" % pull_repo, ref)
                branch = git_output("rev-parse", "FETCH_HEAD").strip()
                git("checkout", "FETCH_HEAD")
                git("fetch", "https://github.com/%s.git" % master_repo, "master")
                master = git_output("rev-parse", "FETCH_HEAD").strip()
                with open("hubbot.master", "w") as master_file:
                    master_file.write("%s\n" % master)
                git("rebase", "FETCH_HEAD")
                rebase_done = True
                os.putenv("TEST_OS", "fedora-21")
                os.putenv("TEST_ARCH", "x86_64")
                os.putenv("TEST_DATA", "%s/cockpit-data/" % os.environ['HOME'])
                os.putenv("TEST_JOBS", "4")
                cmd("./VERIFY")
            set_github_status(master_repo, sha, { "state": "success",
                                                  "description": "Hubbot is happy",
                                                  "target_url": wd.url,
                                                  "context": context })
        except:
            traceback.print_exc()
            if rebase_done:
                description = "Hubbot is sad"
            else:
                description = "Hubbot needs help with rebasing"
            set_github_status(master_repo, sha, { "state": "failure",
                                                  "description": description,
                                                  "target_url": wd.url,
                                                  "context": context })

if len(sys.argv) == 3:
    master_repo = sys.argv[1]
    pull = sys.argv[2]
elif len(sys.argv) == 2:
    master_repo = "cockpit-project"
    pull = sys.argv[1]
else:
    print "Usage: hubbot [MASTER-REPO] PULL"
    print "       hubbot [MASTER-REPO] -"
    print "       hubbot [MASTER-REPO] +"
    print "       hubbot [MASTER-REPO] ~PULL"
    exit(1)

if not "/" in master_repo:
    master_repo = master_repo + "/cockpit"

master = github_get('branches/master')['commit']['sha']

def reset_pull(pull):
    context = "hubbot/f21/x86-64"
    data = github_get("pulls/%s" % pull)
    sha = data['head']['sha']
    set_github_status(master_repo, sha, { "state": "pending",
                                          "description": "Hubbot will do this again",
                                          "context": context })

def master_from_status(status):
    path = "%s/%s/hubbot.master" % (work, os.path.basename(status['target_url']))
    if os.path.isfile(path):
        with open(path, "r") as master_file:
            return master_file.readline().strip()
    else:
        return ""

def consider_head(head):
    context = "hubbot/f21/x86-64"
    status = github_get("commits/%s/status" % head['sha'])
    for s in status['statuses']:
        if s['context'] == context:
            if (s['state'] == 'success' or s['state'] == 'failure'):
                old_master = master_from_status(s)
                if old_master != master:
                    if verbose:
                        print "%s needs verification (master changed)" % head['label']
                        set_github_status(master_repo, head['sha'], { "state": "pending",
                                                                      "description": "Hubbot will do this again because master has changed",
                                                                      "target_url": s['target_url'],
                                                                      "context": context })
                    return True
                    else:
                        if verbose:
                            print "%s already verified" % head['label']
                        return False
            else:
                if verbose:
                    print "%s needs verification (pending or error)" % head['label']
                return True
    if verbose:
        print "%s needs verification (new)" % head['label']
    set_github_status(master_repo, head['sha'], { "state": "pending",
                                                  "description": "Hubbot will get to this eventually",
                                                  "context": context })
    return True

def verify_pull(pull):
    data = None
    if pull == "-":
        pulls = github_get("pulls")
        for p in pulls:
            if p['head']['user']['login'] not in user_whitelist:
                if verbose:
                    print "%s not in whitelist" % p['head']['user']['login']
                continue
            if consider_head(p['head']) and not data:
                data = p
        if not data:
            if verbose:
                print "No verifications pending"
            return False
    else:
        data = github_get("pulls/%s" % pull)
    expire_work_dirs()
    verify (data['head'])
    return True

if pull == "+":
    verify_pull("-")
    exit(0)
elif pull[0] == '~':
    reset_pull(pull[1:])
else:
    verbose = True
    verify_pull(pull)
