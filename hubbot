#! /usr/bin/python

import subprocess
import json
import os
import sys
import errno
import shutil
import traceback
import glob
import ast
import pprint
import time
import datetime

dry_run = False
verbose = False
tail_log = False

new_style = False

is_remote = False

keep_work_dirs = 30
work = "%s/hubbot/" % os.environ['HOME']
work_url = "http://files.cockpit-project.org/hubbot"

config = ast.literal_eval(open("%s/.hubbotrc" % os.environ['HOME']).read())

github_token = config['github_token']
user_whitelist = config['user_whitelist']

master_repo = 'cockpit-project/cockpit'
if 'master_repo' in config:
    master_repo = config['master_repo']

if 'dry_run' in config:
    dry_run = config['dry_run']

if 'remote' in config:
    is_remote = config['remote']

priority_default = 0
priority_needs_attention = 1
priority_work_in_progress = 2

# if something gets tested by a non-default configuration, add this to priority
priority_penalty_other_config = 1

# this is added to priority for checks on master, stacks with priority_penalty_other_config
priority_penalty_master = 1

if 'priority_default' in config:
    priority_default = config['priority_default']
if 'priority_needs_attention' in config:
    priority_needs_attention = config['priority_needs_attention']
if 'priority_work_in_progress' in config:
    priority_work_in_progress = config['priority_work_in_progress']
if 'priority_penalty_other_config' in config:
    priority_penalty_other_config = config['priority_penalty_other_config']
if 'priority_penalty_master' in config:
    priority_penalty_master = config['priority_penalty_master']

# (os name, short name, architecture, offset_master, offset_pull)
os_arch_configurations = [('fedora-22', 'f22', 'x86_64', 0, 0),('rhel-7', 'r7', 'x86_64', -1, 2)]
if 'os_arch' in config and config['os_arch']:
    os_arch_configurations = config['os_arch']

default_arch_config = os_arch_configurations[0]
default_os = default_arch_config[0]
default_short = default_arch_config[1]
default_arch = default_arch_config[2]

if 'default' in config:
    (default_os, default_short, default_arch) = config['default']

pull_status_skip = 'skip'
pull_status_pending = 'pending'
pull_status_running = 'running'
pull_status_finished = 'finished'

status_message_running = 'Hubbot is busy'
status_message_master_changed = 'Hubbot was happy but will do this again because master has changed'

def status_context_from_config(config):
    if config is None:
        config = default_arch_config
    n_suffix = ""
    if "HUBBOT_NEW_STYLE" in os.environ and os.environ["HUBBOT_NEW_STYLE"]:
        n_suffix = "/new"
    return "hubbot/%s/%s%s" % (config[1], config[2].replace('_', '-'), n_suffix)

def trace(msg):
    if verbose:
        print msg

def mk_exclusive_dir(path):
    try:
        os.mkdir(path)
        return True
    except OSError as e:
        if e.errno == errno.EEXIST:
            return False
        else:
            raise e

class WorkDir(object):
    def __init__(self, name):
        i = 0
        n = name
        while not mk_exclusive_dir (os.path.join (work, n)):
            i = i + 1
            n = name + "." + str(i)
        self.path = os.path.join (work, n)
        if work_url:
            self.url = os.path.join (work_url, n, "hubbot.html")

    def __enter__(self):
        trace("Entering %s" % self.path)
        self.oldcwd = os.getcwd()
        os.chdir(self.path)
        self.log = subprocess.Popen("hublog2html >hubbot.html", stdin=subprocess.PIPE, shell=True, bufsize=0)
        if tail_log:
            self.tail = subprocess.Popen([ "tail", "-f", "hubbot.log" ])
        else:
            self.tail = None
        self.old_stdout, self.old_stderr = sys.stdout, sys.stderr
        self.old_stdout.flush(); self.old_stderr.flush()
        sys.stdout = self.log.stdin
        sys.stderr = self.log.stdin
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        sys.stdout = self.old_stdout
        sys.stderr = self.old_stderr
        self.log.stdin.close()
        self.log.wait()
        if self.tail:
            self.tail.kill()
            self.tail.wait()
        trace("Leaving %s" % self.path)

def expire_work_dirs():
    dirs = sorted (map (lambda e: (os.stat(e).st_mtime,e),
                        map (lambda e: os.path.join(work,e),
                             filter (lambda e: e != "data",
                                     os.listdir(work)))),
                   lambda x,y: cmp(x[0],y[0]))
    if len(dirs) > keep_work_dirs:
        for d in dirs[0:len(dirs)-keep_work_dirs]:
            trace("Expiring %s" % d[1])
            shutil.rmtree(d[1])

def cmd(*args):
    print "+", " ".join(list(args))
    subprocess.check_call(list(args), stdout=sys.stdout, stderr=sys.stderr)

def cmd_output(*args):
    return subprocess.check_output(list(args))

def git(*args):
    cmd("git", *args)

def git_output(*args):
    return cmd_output("git", *args)

def github_get_authenticated(url):
    return json.loads(subprocess.check_output ([ "curl", "-s",
                                                 "-u", "%s:x-oauth-basic" % github_token,
                                                 url,
                                               ]))

def github_get(url):
    return json.loads(subprocess.check_output ([ "curl", "-s",
                                                 "-u", "%s:x-oauth-basic" % github_token,
                                                 "https://api.github.com/repos/%s/%s" % (master_repo, url),
                                               ]))

def add_github_comment(issue, message):
    subprocess.check_call ([ "curl", "-s",
                             "-u", "%s:x-oauth-basic" % github_token,
                             "https://api.github.com/repos/%s/issues/%s/comments" % (master_repo, issue),
                             "-d", json.dumps({"body": message})
                           ])

def set_github_status(repo, sha, status):
    if dry_run:
        print "Status %s: %s %s" % (sha, status['state'], status['description'])
    else:
        subprocess.check_output ([ "curl", "-s",
                                   "-u", "%s:x-oauth-basic" % github_token,
                                   "https://api.github.com/repos/%s/statuses/%s" % (repo, sha),
                                   "-d", json.dumps(status)
                                 ])

def add_comment(issue, message):
    if issue:
        add_github_comment(issue, message)
    else:
        print "+++ %s" % message

def verify(head, status_context, is_master=False, clean=False):
    if not is_master:
        pull_repo = head['repo']['full_name']
        ref = head['ref']
        sha = head['sha']
        rebase_done = False
    else:
        sha = head['commit']['sha']
    with WorkDir(sha) as wd:
        try:
            set_github_status(master_repo, sha, { "state": "pending" if not new_style else "success",
                                                  "description": status_message_running,
                                                  "target_url": wd.url,
                                                  "context": status_context })
            if not dry_run:
                git("init")
                if not is_master:
                    git("fetch", "https://github.com/%s.git" % pull_repo, ref)
                    branch = git_output("rev-parse", "FETCH_HEAD").strip()
                    git("checkout", "FETCH_HEAD")
                    git("fetch", "https://github.com/%s.git" % master_repo, "master")
                    master = git_output("rev-parse", "FETCH_HEAD").strip()
                    with open("hubbot.master", "w") as master_file:
                        master_file.write("%s\n" % master)
                    git("rebase", "FETCH_HEAD")
                    rebase_done = True
                else:
                    git("fetch", "https://github.com/%s.git" % master_repo, "master")
                    git("checkout", "FETCH_HEAD")
                    # make sure we test exactly the specified revision, maybe someone pushed a new commit in the interim
                    git("reset", "--hard", sha)

                if new_style:
                    os.putenv("GUESTOS", "fedora22-cockpit")
                    os.putenv("GUEST_NUMBER", "22")
                    cmd("./VERIFY.new")
                else:
                    os.putenv("TEST_OS", default_os)
                    os.putenv("TEST_ARCH", default_arch)
                    for config in os_arch_configurations:
                        if status_context == status_context_from_config(config):
                            os.putenv("TEST_OS", config[0])
                            os.putenv("TEST_ARCH", config[1])
                            break
                    os.putenv("TEST_DATA", "%s/cockpit-data/" % os.environ['HOME'])
                    os.putenv("TEST_JOBS", "4")
                    if clean:
                        cmd("./VERIFY", "--clean")
                    else:
                        cmd("./VERIFY")
            set_github_status(master_repo, sha, { "state": "success",
                                                  "description": "Hubbot is happy",
                                                  "target_url": wd.url,
                                                  "context": status_context })
        except:
            traceback.print_exc()
            if is_master:
                description = "Hubbot is sad"
            else:
                if rebase_done:
                    description = "Hubbot is sad"
                else:
                    description = "Hubbot needs help with rebasing"
            set_github_status(master_repo, sha, { "state": "failure" if not new_style else "success",
                                                  "description": description,
                                                  "target_url": wd.url,
                                                  "context": status_context })

def master_from_status(status):
    path = "%s/%s/hubbot.master" % (work, os.path.basename(os.path.dirname(status['target_url'])))
    if os.path.isfile(path):
        with open(path, "r") as master_file:
            return master_file.readline().strip()
    else:
        if is_remote:
            path = "%s/hubbot.master" % os.path.dirname(status['target_url'])
            sha = subprocess.check_output ([ "curl", "-s", path ]).strip()
            if len(sha) > 40 or "404 Not Found" in sha:
                return ""
            else:
                return sha
        else:
            return ""

def status_is_success(status):
    return status['state'] == 'success' and status['description'] == "Hubbot is happy"

def status_is_pending(status):
    return status['state'] == 'pending' or status['description'] == status_message_master_changed or status['description'] == "Hubbot will get to this eventually"

def consider_head(head, master, status_context):
    status = github_get("commits/%s/status" % head['sha'])
    for s in status['statuses']:
        if s['context'] == status_context:
            if status_is_success(s):
                old_master = master_from_status(s)
                if old_master != master:
                    trace("%s needs verification (master changed)" % head['label'])
                    set_github_status(master_repo, head['sha'], { "state": "success",
                                                                  "description": status_message_master_changed,
                                                                  "target_url": s['target_url'],
                                                                  "context": status_context })
                    return (pull_status_pending, 'already passed, but master changed')
                else:
                    trace("%s already verified" % head['label'])
                    return (pull_status_finished, 'passed')
            elif s['description'] == status_message_master_changed:
                return (pull_status_pending, 'already passed, but master changed')
            elif s['state'] == 'error':
                trace("%s needs verification (error)" % head['label'])
                return (pull_status_pending, '')
            elif status_is_pending(s):
                trace("%s needs verification (pending)" % head['label'])
                if (s['description'] == status_message_running):
                    return (pull_status_running, '')
                return (pull_status_pending, '')
            elif s['description'] == "Hubbot needs help with rebasing":
                return (pull_status_finished, 'failed, needs rebase')
            else:
                trace("%s already failed" % head['label'])
                return (pull_status_finished, 'failed')
    trace("%s needs verification (new)" % head['label'])
    set_github_status(master_repo, head['sha'], { "state": "pending" if not new_style else "success",
                                                  "description": "Hubbot will get to this eventually",
                                                  "context": status_context })
    return (pull_status_pending, '')

def get_user_html(url):
    user_info = github_get_authenticated(url)
    return user_info['html_url']


def print_jobs_table(title, jobs):
    if not jobs:
        return """
      <div class="container">
      <h2>%s</h2>
      <p>No entries.</p>
      </div><!-- /.container -->
""" % (title)
    text = """
    <div class="container">

      <h2>%s</h2>
      <table class="table">
        <thead>
          <tr>
            <th>Title</th>
            <th>User</th>
            <th>Status</th>
            <th>Priority</th>
            <th>Configuration</th>
            <th>Comment</th>
          </tr>
        </thead>
        <tbody>
""" % (title)
    for job in jobs:
        job_class = ''
        if job[2] == pull_status_running:
            job_class = 'info'
        elif job[2] == pull_status_finished:
            if 'passed' in job[3]:
                job_class = 'success'
            elif 'failed' in job[3]:
                job_class = 'danger'
        elif job[2] == pull_status_pending and 'passed' in job[3]:
            job_class = 'success'
        elif job[3] == 'rejected user':
            job_class = 'warning'
        is_pull_request = job[4]

        if is_pull_request:
            p = job[0]
            head = p['head']
            job_desc = "<a href=\"%s\">%s</a>" % (p['html_url'], p['title'])
            user_html = get_user_html(head['user']['url'])
            if user_html:
                user_login = "<a href=\"%s\">%s</a>" % (user_html, head['user']['login'])
            else:
                user_login = head['user']['login']
            sha = head['sha']
        else:
            m = job[0]
            if m['commit']:
                c = m['commit']
                if c['sha']:
                    sha = m['commit']['sha']
                if c['author'] and c['author']['login']:
                    user_html = get_user_html(c['author']['url'])
                    if user_html:
                        user_login = "<a href=\"%s\">%s</a>" % (user_html, c['author']['login'])
                    else:
                        user_login = c['author']['login']
                if c['committer'] and c['committer']['login']:
                    user_html = get_user_html(c['committer']['url'])
                    committer_login = c['committer']['login']
                    if user_html:
                        user_login += " (committed by <a href=\"%s\">%s</a>)" % (user_html, committer_login)
                    else:
                        user_login += " (committed by %s)" % (committer_login)
                if m['_links'] and m['_links']['html']:
                    job_desc = "<a href=\"%s\">master</a>" % (m['_links']['html'])
                else:
                    job_desc = 'master'
            pass

        status_context = job[5]
        comment = job[3]
        # get status, filtered by entries that concern us
        status = github_get("commits/%s/status" % (sha))
        if status and status['statuses']:
            status = filter(lambda s: s['context'] == status_context and
                                      'hubbot' in "%s" % (s['target_url']),
                            status['statuses'])
        if status:
            # most recent entry will be first
            hubbot_link = "<a href=\"%s\">hubbot output</a>" % (status[0]['target_url'])
            if len(comment) > 0:
                comment += " (%s)" % (hubbot_link)
            else:
                comment = hubbot_link

        text = text + """
          <tr class="%s">
            <td>%s</td>
            <td>%s</td>
            <td>%s</td>
            <td>%s</td>
            <td>%s</td>
            <td>%s</td>
          </tr>""" % (job_class, job_desc, user_login, job[2], job[1], status_context, comment)
    text = text + """
        </tbody>
      </table>
    </div><!-- /.container -->
"""
    return text

# Publish scan info in html format
def publish_status(extended_info):
    header = """<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="Cockpit Project">
    <!--<link rel="icon" href="../../favicon.ico">-->

    <title>Cockpit - Hubbot Status</title>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.min.css">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <h1>Status at: %s UTC</h1>
""" % (datetime.datetime.utcnow())
    footer = """
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Latest compiled and minified JavaScript -->
    <!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>-->
  </body>
</html>
"""
    # print all elements in their respective category
    tables = print_jobs_table('pending jobs', filter(lambda p: p[2] in [pull_status_pending, pull_status_running], extended_info))
    tables += print_jobs_table('finished jobs', filter(lambda p: p[2] == pull_status_finished, extended_info))
    tables += print_jobs_table('skipped jobs', filter(lambda p: p[2] == pull_status_skip, extended_info))

    # write finished html file
    with open("%sindex.html" % (work), "w") as out_file:
        out_file.write(header + tables + footer)

def get_sorted_pulls():
    pulls = github_get("pulls")
    # Pulls with a lower priority will be checked first
    viable_pulls = [ ];
    for p in pulls:
        priority = priority_default
        if p['title'].lower().startswith('wip'):
            priority = priority_work_in_progress
        else:
            # check labels
            p_labels = github_get("issues/%s/labels" % p['number'])
            for l in p_labels:
                if l['name'] in ['needswork', 'needsdesign']:
                    priority = priority_needs_attention
        for config in os_arch_configurations:
            status_context = status_context_from_config(config)
            priority_offset = config[4]
            if config != default_arch_config:
                priority_offset += priority_penalty_other_config
            viable_pulls.append([p, priority+priority_offset, status_context])

    # sort by priority
    return sorted(viable_pulls, key=lambda x: x[1])

def consider_master(master, get_only=False):
    master_sha = master['commit']['sha']
    status = github_get("commits/%s/status" % (master_sha))

    # consider all configurations
    viable_checks = []
    for config in os_arch_configurations:
        status_context = status_context_from_config(config)
        priority = config[3] + priority_default + priority_penalty_master
        if config != default_arch_config:
            priority += priority_penalty_other_config
        entry = [master, priority, pull_status_pending, '', False, status_context]
        status_found = False
        for s in status['statuses']:
            if s['context'] == status_context:
                status_found = True
                if status_is_success(s):
                    trace("master passed for config %s" % status_context)
                    entry[2] = pull_status_finished
                    entry[3] = 'passed'
                elif s['state'] == 'error':
                    trace("master needs verification (error) for config %s" % status_context)
                    entry[2] = pull_status_pending
                    entry[3] = 'error'
                elif status_is_pending(s):
                    trace("master needs verification (pending) for config %s" % status_context)
                    if (s['description'] == status_message_running):
                        entry[2] = pull_status_running
                        entry[3] = ''
                    else:
                        # pending, no comment is default: no need to update entry
                        pass
                else:
                    trace("master failed for config %s" % status_context)
                    entry[2] = pull_status_finished
                    entry[3] = 'failed'
                # we found the newest status, don't check older ones
                break

        # if there was no status, then this is new and needs to be marked as pending
        if not status_found and not get_only:
            # pending, no comment is default: no need to update entry
            trace("master needs verification for config %s" % status_context)
            set_github_status(master_repo, master_sha, { "state": "pending" if not new_style else "success",
                                                         "description": "Hubbot will get to this eventually",
                                                         "context": status_context })
        viable_checks.append(entry)


    # sort by priority
    return sorted(viable_checks, key=lambda x: x[1])

def scan_pulls():
    pulls = get_sorted_pulls()
    master = github_get('branches/master')
    master_sha = master['commit']['sha']
    extended_info = []
    for pull_info in pulls:
        p = pull_info[0]
        if p['head']['user']['login'] not in user_whitelist:
            trace("%s not in whitelist" % p['head']['user']['login'])
            extended_info.append((p, pull_info[1], pull_status_skip, 'rejected user', True, pull_info[2]))
            continue
        (pull_status, pull_comment) = consider_head(p['head'], master_sha, pull_info[2])
        extended_info.append((p, pull_info[1], pull_status, pull_comment, True, pull_info[2]))
    master_info = consider_master(master)
    if master_info:
        extended_info.extend(master_info)
        # sort by priority
        extended_info = sorted(extended_info, key=lambda x: x[1])
    publish_status(extended_info)

def head_is_pending(head, status_context):
    status = github_get("commits/%s/status" % head['sha'])
    for s in status['statuses']:
        if s['context'] == status_context and status_is_pending(s):
            return True
    return False

def verify_pull(pull):
    data = None
    is_master_check = False
    status_context = status_context_from_config(default_arch_config)
    if pull == "-":
        pulls = get_sorted_pulls()
        # use first pending pull in sorted list
        for pull_info in pulls:
            p = pull_info[0]
            if head_is_pending(p['head'], pull_info[2]):
                data = p
                priority = pull_info[1]
                status_context = pull_info[2]
                break

        # consider checking master
        master = github_get('branches/master')
        master_sha = master['commit']['sha']
        master_info = consider_master(master, True)
        for info in master_info:
            if info[2] != pull_status_pending:
                continue
            # we need to be of a higher priority than the pull request
            if data is None or info[1] >= priority:
                continue
            data = info[0]
            is_master_check = True
            status_context = info[5]

        if data is None:
            trace("No verifications pending")
            return

    else:
        data = github_get("pulls/%s" % pull)

    expire_work_dirs()
    clean = False

    if is_master_check:
        trace("Verifying master for config %s%s" % (status_context, " (cleanly)" if clean else ""))
        verify(data, status_context, True, clean)
    else:
        labels = github_get("issues/%s/labels" % data['number'])
        for l in labels:
            if l['name'] == "hubbot:makeimages":
                clean = True
                break
        trace("Verifying %s%s" % (data['head']['label'], " (cleanly)" if clean else ""))
        verify(data['head'], status_context, False, clean)

if "HUBBOT_NEW_STYLE" in os.environ and os.environ["HUBBOT_NEW_STYLE"]:
    new_style = True
    work = "%s/hubbot.new/" % os.environ['HOME']
    work_url = "http://files.cockpit-project.org/hubbot.new"

def print_usage():
    print "Usage: hubbot verify [ [REPO] PULL ]"
    print "       hubbot scan [REPO]"

if dry_run:
    print "hubbot dry run"


if len(sys.argv) < 2:
    print_usage()
    exit(1)

elif sys.argv[1] == 'verify' and len(sys.argv) <= 4:
    if len(sys.argv) == 4:
        master_repo = sys.argv[2]
        pull = sys.argv[3]
    elif len(sys.argv) == 3:
        pull = sys.argv[3]
    else:
        pull = "-"

    if not "/" in master_repo:
        master_repo = master_repo + "/cockpit"
    verify_pull(pull)

elif sys.argv[1] == 'scan' and len(sys.argv) <= 3:
    if len(sys.argv) == 3:
        master_repo = sys.argv[2]

    if not "/" in master_repo:
        master_repo = master_repo + "/cockpit"
    scan_pulls()

else:
    print_usage()
    exit(1)
